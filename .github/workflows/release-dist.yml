# Copyright 2022-2024, axodotdev
# SPDX-License-Identifier: MIT or Apache-2.0
#
# CI that:
#
# * checks for a Git Tag that looks like a release
# * builds artifacts with cargo-dist (archives, installers, hashes)
# * uploads those artifacts to temporary workflow zip
# * on success, uploads the artifacts to a GitHub Release
#
# Note that the GitHub Release will be created with a generated
# title/body based on your changelogs.

name: Release with cargo-dist

permissions:
  contents: write

# This task will run whenever you push a git tag that looks like a version
# like "1.0.0", "v0.1.0-prerelease.1", "my-app/0.1.0", "releases/v1.0.0", etc.
# Various formats will be parsed, see the documentation for more details.
on:
  workflow_dispatch:
  push:
    tags:
      - '**[0-9]+.[0-9]+.[0-9]+*'

jobs:
  # Run 'cargo dist plan' (or host) to determine what tasks we need to do
  plan:
    runs-on: ubuntu-latest
    outputs:
      val: ${{ steps.plan.outputs.manifest }}
      tag: ${{ steps.outputs.outputs.tag }}
      tag-flag: ${{ steps.outputs.outputs.tag-flag }}
      publishing: ${{ steps.outputs.outputs.publishing }}
      env: ${{ steps.outputs.outputs.env }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Install cargo-dist
        # we specify bash to get pipefail; it guards against the `curl` command
        # failing. otherwise `sh` won't catch that `curl` returned non-0
        shell: bash
        run: |
          cargo install --git "https://github.com/axodotdev/cargo-dist" --tag "v0.25.1" cargo-dist
      - name: Run cargo-dist plan
        id: plan
        run: |
          cargo dist plan --tag="${{ github.ref_name }}" --output-format=json > plan-dist-manifest.json
          echo "manifest=$(cat plan-dist-manifest.json)" >> "$GITHUB_OUTPUT"
      - name: Check plan
        run: |
          echo "MANIFEST:"
          jq . plan-dist-manifest.json
      - name: Post Step Outputs
        id: outputs
        shell: bash
        run: |
          echo "tag=$(jq --raw-output ".announcement_tag" plan-dist-manifest.json)" >> "$GITHUB_OUTPUT"
          echo "tag-flag=--tag=$(jq --raw-output ".announcement_tag" plan-dist-manifest.json)" >> "$GITHUB_OUTPUT"
          echo "publishing=$(jq --raw-output ".announcement_is_prerelease" plan-dist-manifest.json)" >> "$GITHUB_OUTPUT"
          echo "env=$(jq --raw-output ".ci.github.caches_enabled" plan-dist-manifest.json)" >> "$GITHUB_OUTPUT"

  # Build and packages all the platform-specific things
  build-local-artifacts:
    name: build-local-artifacts (${{ join(matrix.targets, ', ') }})
    # Let the initial task tell us to not run (e.g. if you don't have any binaries)
    needs:
      - plan
    if: ${{ fromJson(needs.plan.outputs.val).ci.github.artifacts_matrix.include != null && (needs.plan.outputs.publishing == 'true' || fromJson(needs.plan.outputs.val).ci.github.pr_run_mode == 'upload') }}
    strategy:
      fail-fast: false
      # Target platforms/runners are computed by cargo-dist in create-release.
      # Each member of the matrix has the following arguments:
      #
      # - runner: the github runner
      # - dist-args: cli flags to pass to cargo dist
      # - install-dist: expression to run to install cargo-dist on the runner
      #
      # Typically there will be:
      # - 1 "global" task that builds universal installers
      # - N "local" tasks that build each platform's binaries and platform-specific installers
      matrix: ${{ fromJson(needs.plan.outputs.val).ci.github.artifacts_matrix }}
    runs-on: ${{ matrix.runner }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      BUILD_MANIFEST_NAME: target/distrib/${{ join(matrix.targets, '-') }}-dist-manifest.json
    steps:
      - name: enable windows longpaths
        run: |
          git config --global core.longpaths true
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Install cargo-dist
        run: ${{ matrix.install_dist }}
      # Get all the local artifacts for the global tasks to use (for e.g. checksums)
      - name: Fetch local artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: target/distrib/
          merge-multiple: true
      - name: Build artifacts
        run: |
          # Actually do builds and make zips and whatnot
          cargo dist build ${{ needs.plan.outputs.tag-flag }} --print=verbose --output-format=json ${{ matrix.dist_args }} > dist-manifest.json
          echo "MANIFEST:"
          jq . dist-manifest.json
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-${{ join(matrix.targets, '-') }}
          path: |
            ${{ steps.cargo-dist.outputs.paths }}
            dist-manifest.json
      # Build and upload debug symbols for supported platforms
      - name: Build debug symbols (Windows)
        if: contains(matrix.targets, 'windows')
        shell: pwsh
        run: |
          cargo build --release --target ${{ matrix.targets[0] }}
          # Create PDB files for Windows
          Get-ChildItem -Path "target\${{ matrix.targets[0] }}\release" -Filter "*.pdb" | ForEach-Object {
            $symbolsDir = "symbols\${{ matrix.targets[0] }}"
            New-Item -ItemType Directory -Force -Path $symbolsDir
            Copy-Item $_.FullName -Destination $symbolsDir
          }
      - name: Upload debug symbols
        if: contains(matrix.targets, 'windows')
        uses: actions/upload-artifact@v4
        with:
          name: symbols-${{ join(matrix.targets, '-') }}
          path: symbols/

  # Build and package all the platform-agnostic(ish) things
  build-global-artifacts:
    needs:
      - plan
      - build-local-artifacts
    runs-on: "ubuntu-20.04"
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      BUILD_MANIFEST_NAME: global-dist-manifest.json
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Install cargo-dist
        shell: bash
        run: |
          cargo install --git "https://github.com/axodotdev/cargo-dist" --tag "v0.25.1" cargo-dist
      # Get all the local artifacts for the global tasks to use (for e.g. checksums)
      - name: Fetch local artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: target/distrib/
          merge-multiple: true
      - name: Build artifacts
        id: cargo-dist
        shell: bash
        run: |
          cargo dist build ${{ needs.plan.outputs.tag-flag }} --print=verbose --output-format=json "--artifacts=global" > dist-manifest.json
          echo "MANIFEST:"
          jq . dist-manifest.json
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-global
          path: |
            ${{ steps.cargo-dist.outputs.paths }}
            dist-manifest.json

  # Determines if we should publish/announce
  host:
    needs:
      - plan
      - build-local-artifacts
      - build-global-artifacts
    # Only run if we're "publishing", and only if local and global didn't fail (skipped is fine)
    if: ${{ always() && needs.plan.outputs.publishing == 'true' && (needs.build-global-artifacts.result == 'skipped' || needs.build-global-artifacts.result == 'success') && (needs.build-local-artifacts.result == 'skipped' || needs.build-local-artifacts.result == 'success') }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    runs-on: "ubuntu-20.04"
    outputs:
      val: ${{ steps.host.outputs.manifest }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Install cargo-dist
        run: |
          cargo install --git "https://github.com/axodotdev/cargo-dist" --tag "v0.25.1" cargo-dist
      # Fetch artifacts from scratch-storage
      - name: Fetch artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: target/distrib/
          merge-multiple: true
      - name: Fetch debug symbols
        uses: actions/download-artifact@v4
        with:
          pattern: symbols-*
          path: symbols/
          merge-multiple: true
        continue-on-error: true
      # Upload debug symbols to a separate release asset
      - name: Package debug symbols
        if: hashFiles('symbols/**') != ''
        run: |
          tar czf kindly-guard-symbols-${{ needs.plan.outputs.tag }}.tar.gz symbols/
      - name: Cargo-dist host
        id: host
        shell: bash
        run: |
          cargo dist host ${{ needs.plan.outputs.tag-flag }} --steps=upload --steps=release --output-format=json > dist-manifest.json
          echo "MANIFEST:"
          jq . dist-manifest.json
          echo "manifest=$(cat dist-manifest.json)" >> "$GITHUB_OUTPUT"
      - name: Upload debug symbols to release
        if: hashFiles('kindly-guard-symbols-*.tar.gz') != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload ${{ needs.plan.outputs.tag }} kindly-guard-symbols-*.tar.gz

  # Publish packages to package managers
  publish-homebrew-formula:
    needs:
      - plan
      - host
    runs-on: "ubuntu-20.04"
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      PLAN: ${{ needs.plan.outputs.val }}
      GITHUB_USER: "samduchaine"
      HOMEBREW_TAP: "samduchaine/homebrew-tap"
    if: ${{ !fromJson(needs.plan.outputs.val).announcement_is_prerelease || fromJson(needs.plan.outputs.val).publish_prereleases }}
    steps:
      - name: "Install cargo-dist"
        run: |
          cargo install --git "https://github.com/axodotdev/cargo-dist" --tag "v0.25.1" cargo-dist
      - name: Fetch homebrew formulae
        uses: actions/download-artifact@v4
        with:
          name: artifacts-global
          path: Formula/
      - name: Commit formula files
        run: |
          git config --global user.name "${GITHUB_USER}"
          git config --global user.email "${GITHUB_USER}@users.noreply.github.com"

          # Clone the homebrew-tap repo
          git clone https://github.com/${HOMEBREW_TAP}.git homebrew-tap
          cd homebrew-tap

          # Copy generated formulae
          cp ../Formula/*.rb Formula/ 2>/dev/null || echo "No formulae found"

          # Commit and push if there are changes
          git add -A
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update KindlyGuard formula to ${{ needs.plan.outputs.tag }}"
            git push
          fi

  announce:
    needs:
      - plan
      - host
    # Only run if we're "publishing" and uploading to GitHub Releases worked
    if: ${{ always() && needs.plan.outputs.publishing == 'true' && needs.host.result == 'success' }}
    runs-on: "ubuntu-20.04"
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      # Trigger any external announcement webhooks
      - name: Trigger announcement webhooks
        run: |
          echo "Release ${{ needs.plan.outputs.tag }} has been published!"
          # Add any webhooks or notifications here